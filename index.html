// ... (Rest of the <head> and <style> tags remain the same) ...

    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <script>
        // ... (Component description remains the same) ...

        AFRAME.registerComponent('placement-helper', {
            schema: {
                target: {type: 'selector', default: '#model'}, // The entity to place
                reticle: {type: 'selector', default: '#reticle'} // The reticle entity
            },

            init: function () {
                const el = this.el;
                const scene = el.sceneEl;

                // State variables
                this.xrHitTestSource = null;
                this.modelPlaced = false;

                // Bind handlers
                this.onTap = this.onTap.bind(this);
                // NOTE: Removed the separate touch handler. The click event on the canvas
                // often fires for a touch *and* a mouse click in modern browsers.
                
                // Wait for the AR session to start
                scene.addEventListener('ar-start', (event) => {
                    // Use the A-Frame scene-level 'click' event for placement.
                    // This is generally better than using canvas.addEventListener('click')
                    // because A-Frame normalizes tap/click events.
                    scene.addEventListener('click', this.onTap);
                    
                    // We don't need to save the session explicitly, but the context is useful
                    // this.xrSession = scene.renderer.xr.getSession(); 
                    this.setupHitTest();
                });

                scene.addEventListener('ar-end', () => {
                    // Remove listener when AR ends
                    scene.removeEventListener('click', this.onTap);
                    this.xrHitTestSource = null;
                    this.modelPlaced = false; // Reset state for next AR session
                    
                    // Hide model/reticle if AR ends abruptly
                    this.data.target.object3D.visible = false;
                    this.data.reticle.object3D.visible = false;
                    document.getElementById('status-message').innerText = 'AR Session ended. Enter AR mode first.';
                });
            },

            async setupHitTest() {
                const scene = this.el.sceneEl;
                const session = scene.renderer.xr.getSession();
                if (!session) return;

                // The reference space to perform hit-testing in (usually 'viewer')
                const xrReferenceSpace = await session.requestReferenceSpace('viewer');
                
                // Request a persistent hit test source
                session.requestHitTestSource({ space: xrReferenceSpace })
                    .then(hitTestSource => {
                        this.xrHitTestSource = hitTestSource;
                        console.log('WebXR Hit Test Source acquired.');
                    })
                    .catch(err => {
                        console.error('Could not get hit test source:', err);
                    });
            },

            tick: function (t, dt) {
                // ... (tick function is correct, no changes needed) ...
                if (!this.el.sceneEl.is('ar-mode') || !this.xrHitTestSource || this.modelPlaced) {
                    this.data.reticle.object3D.visible = false;
                    return;
                }
                
                const frame = this.el.sceneEl.frame;
                const referenceSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();

                if (frame && referenceSpace) {
                    const hitTestResults = frame.getHitTestResults(this.xrHitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        // Update reticle position and visibility
                        this.data.reticle.object3D.position.copy(pose.transform.position);
                        this.data.reticle.object3D.quaternion.copy(pose.transform.orientation);
                        this.data.reticle.object3D.visible = true;
                        
                        // Store the latest position for placement on tap
                        this.lastDetectedPosition = pose.transform.position;
                    } else {
                        // Hide reticle if no surface is found
                        this.data.reticle.object3D.visible = false;
                    }
                }
            },

            onTap: function (evt) {
                // The check for scroll/swipe is removed as we are now using the A-Frame 'click'
                // event, which is triggered after a brief tap gesture.

                if (!this.modelPlaced && this.lastDetectedPosition) {
                    // Place the model at the last detected surface position
                    const model = this.data.target;
                    model.setAttribute('position', {
                        x: this.lastDetectedPosition.x,
                        y: this.lastDetectedPosition.y,
                        z: this.lastDetectedPosition.z
                    });
                    
                    // Make the model visible and the reticle disappear
                    model.object3D.visible = true;
                    this.data.reticle.object3D.visible = false;
                    this.modelPlaced = true;
                    
                    // Update UI message
                    document.getElementById('status-message').innerText = 'Model placed! You can now move around it.';
                } else if (this.modelPlaced) {
                    console.log('Model already placed.');
                }
            }
        });
    </script>
</head>
<body>
// ... (Rest of the <body> section remains the same) ...